package usc.edu.SALEM.GA;

import usc.edu.SALEM.Constants;
import usc.edu.SALEM.SALEM;
import usc.edu.SALEM.util.Util;

import java.io.IOException;
import java.util.*;

public class GASearch {


    private final GAChromosome initialChromosome;
    private List<GAChromosome> currentPopulation;
    private List<GAChromosome> nextGeneration;
    private static int generationCount;

    public GASearch(GAChromosome chromosome) {
        this.initialChromosome = chromosome;
        this.currentPopulation = new ArrayList<GAChromosome>();
        this.nextGeneration = new ArrayList<GAChromosome>();
        generationCount = 0;
    }

    public static int getGenerationCount() {
        return generationCount;
    }

    public static void setGenerationCount(int generationCount) {
        GASearch.generationCount = generationCount;
    }

    private void initialize(int populationSize) {
        // initialize first chromosome with all genes as suggested values from Google
        GAChromosome c = initialChromosome.copy();
        for (GAGene g : initialChromosome.getGenes()) {
            GAGene newGene = g.copy();
            newGene.setValue(Constants.ACCESSIBILITY_SUGGESTED_VALUES.get(g.getIssueType()).get(g.getCssProperty()));
            c.replaceGene(g, newGene);
        }
        c.addOriginToTrace("initialization");
        currentPopulation.add(c);

        // initialize other chromosomes in the population
        for (int i = 1; i < populationSize; i++) {
            GAChromosome temp = initialChromosome.copy();
            for (GAGene g : initialChromosome.getGenes()) {

                GAGene newGene = g.copy();
                List<Double> inputs = Util.generateGaussianInputs(g.getIssueType());
                double val = Util.getGaussianValue(inputs.get(0), inputs.get(1), inputs.get(2));

                newGene.setValue(String.valueOf(val)); // no need to add  unit, I am adding that later when getting elements to change
//                newGene.setValue(val + "dp");

                temp.replaceGene(g, newGene);
            }
            temp.addOriginToTrace("initialization");
            currentPopulation.add(temp);
        }
    }

    public void sortPopulationByFitnessScore(List<GAChromosome> population) {
        // descending order of fitness score
        Collections.sort(population);
    }

    private GAChromosome selectParent() {
        // roulette wheel selection
        double populationSum = 0;
        List<GAChromosome> tempPopulation = new ArrayList<GAChromosome>(currentPopulation);

        Collections.shuffle(tempPopulation);

        for (GAChromosome c : tempPopulation) {
            populationSum = populationSum + c.getFitnessFunctionObj().getFitnessScore();
        }

        double r = Math.random();
        double sum = 0.0;
        for (GAChromosome c : tempPopulation) {
            double probability = c.getFitnessFunctionObj().getFitnessScore() / populationSum;
            sum = sum + probability; // probability -> as the fitness function
            // is maximizing
            if (r < sum) {
                return c;
            }
        }
        return currentPopulation.get(0);
    }

    private List<GAChromosome> crossover() {
        List<GAChromosome> nextGenerationCrossover = new ArrayList<>();

        int numberOfCrossovers = (int) Math.round(currentPopulation.size() * Constants.CROSSOVER_RATE);
        System.out.println("Number of crossovers to be performed = " + numberOfCrossovers);
        for (int n = 0; n < numberOfCrossovers; n++) {
            System.out.println("Crossover no. " + (n + 1));
            GAChromosome parent1 = selectParent();
            GAChromosome parent2 = selectParent();

            // uniform crossover
            int numberOfGenesToProcess = Util.getRandomIntValueInRange(1, parent1.getGenes().size() + 1);
            Set<Integer> geneIndicesToProcess = new HashSet<Integer>();
            int lastIndex = parent1.getGenes().size();
            if (lastIndex > parent2.getGenes().size()) {
                lastIndex = parent2.getGenes().size();
            }
            for (int i = 0; i < numberOfGenesToProcess; i++) {
                int randomGeneIndex = Util.getRandomIntValueInRange(0, lastIndex - 1);
                geneIndicesToProcess.add(randomGeneIndex);
            }
            // System.out.println("Parent 1 = " + parent1);
            // System.out.println("Parent 2 = " + parent2);
            // System.out.println("Gene indices to process = " +
            // geneIndicesToProcess);

            // add four children generated by uniform crossover to next

            // generation
            List<GAChromosome> children1 = createChildUniformCrossover(parent1, parent2, geneIndicesToProcess);
            for (GAChromosome child1 : children1) {
                child1.addOriginToTrace("crossover_gen" + generationCount);
                nextGenerationCrossover.add(child1);
            }


//			List<GAChromosome> children2 = extractGenesBasedOnIssueTypeSegmentRelationGraphChildUniformCrossover(parent2, parent1, geneIndicesToProcess);
//			for (GAChromosome child2 : children2) {
//				computeFitnessScore(child2);
//				nextGeneration.add(child2);
//			}

/*			List<GAChromosome> children2 = createChildUniformCrossover(parent2, parent1, geneIndicesToProcess);
			for (GAChromosome child2 : children2) {
				nextGenerationCrossover.add(child2);
			}
*/
        }
        return nextGenerationCrossover;
    }


    private List<GAChromosome> createChildUniformCrossover(GAChromosome parent1, GAChromosome parent2,
                                                           Set<Integer> geneIndicesToProcess) {
        List<GAChromosome> children = new ArrayList<GAChromosome>();

        GAChromosome child1 = parent1.copy();
        GAChromosome child2 = parent1.copy();
        for (int i : geneIndicesToProcess) {

            GAGene oldGene = child1.getGene(i);
            GAGene oldGene2 = child2.getGene(i);
            double alpha = Util.getRandomDoubleValueInRange(0.0, 1.0);
            double value1 = Util.getNumbersFromString(parent1.getGene(i).getValue()).get(0);
            String unit = Util.getUnitFromStringValue(parent1.getGene(i).getValue());
            double value2 = Util.getNumbersFromString(parent2.getGene(i).getValue()).get(0);
            GAGene newGene1 = new GAGene(oldGene.getXpaths(), oldGene.getCssProperty(), oldGene.getIssueType(),
                    Util.getWeightedAverage(value1, value2, alpha) + unit, oldGene.getSegmentIssueId());
            newGene1.setOriginalValue(oldGene.getOriginalValue());
            GAGene newGene2 = new GAGene(oldGene2.getXpaths(), oldGene2.getCssProperty(), oldGene2.getIssueType(),
                    Util.getWeightedAverage(value2, value1, alpha) + unit, oldGene2.getSegmentIssueId());
            newGene2.setOriginalValue(oldGene2.getOriginalValue());
            child1.replaceGene(oldGene, newGene1);
            child2.replaceGene(oldGene2, newGene2);
        }
        children.add(child1);
        children.add(child2);
        return children;
    }

    private List<GAChromosome> mutation() {
        List<GAChromosome> nextGenerationMutation = new ArrayList<>();
        int numberOfChromosomesToMutate = (int) Math.round(currentPopulation.size() * Constants.MUTATION_RATE);
        System.out.println("Number of chromosomes to mutate = " + numberOfChromosomesToMutate);
        for (int i = 0; i < numberOfChromosomesToMutate; i++) {
            int randomChromosomeIndex = Util.getRandomIntValueInRange(0, currentPopulation.size());
            GAChromosome mutatedChromosome = currentPopulation.get(randomChromosomeIndex).copy();

            int numberOfGenesToMutate = Util.getRandomIntValueInRange(1, mutatedChromosome.getGenes().size() + 1);
            for (int j = 0; j < numberOfGenesToMutate; j++) {
                int randomGeneIndex = Util.getRandomIntValueInRange(0, mutatedChromosome.getGenes().size());
                GAGene geneToMutate = mutatedChromosome.getGene(randomGeneIndex);
                GAGene mutatedGene = geneToMutate.copy();
                // TODO Guassian
                // uniform mutation with a random value chosen between [-30, 30]

                // String val =
                // Util.getNumbersFromString(geneToMutate.getValue()).get(0) +
                // Util.getRandomIntValueInRange(0, 30) +
                // Util.getUnitFromStringValue(geneToMutate.getValue());
                List<Double> inputs = Util.generateGaussianInputs(geneToMutate.getIssueType());
                //original value Util.getNumbersFromString(geneToMutate.getValue()).get(0)

                String val = Util.getGaussianValue(inputs.get(0), inputs.get(1), inputs.get(2))
                        + Util.getUnitFromStringValue(geneToMutate.getValue());
                //System.out.println(val + " guass ");
                mutatedGene.setValue(val);
                mutatedChromosome.replaceGene(geneToMutate, mutatedGene);
            }
            mutatedChromosome.addOriginToTrace("mutation_gen" + generationCount);
            nextGenerationMutation.add(mutatedChromosome);
        }
        return nextGenerationMutation;
    }

    private void select() {
        // sort population by fitness score
        sortPopulationByFitnessScore(nextGeneration);

        // add only top "POPULATION_SIZE" chromosomes to the new current
        // population
        currentPopulation = new ArrayList<GAChromosome>();
        for (int i = 0; i < Constants.POPULATION_SIZE; i++) {
            // TODO problem here out of bound
            if (i < nextGeneration.size())
                currentPopulation.add(nextGeneration.get(i));
        }
    }

    private boolean isTerminate(int generationCount, int saturationCount, double usabilityScore) {

        boolean terminate = false;
		/*if(usabilityScore >= Constants.USABILITY_SCORE_THRESHOLD)
		{
			terminate = true;
			System.out.println("Terminating because usability score greater than or equal to the threshold " + Constants.USABILITY_SCORE_THRESHOLD);
		}
		else */
        if (generationCount >= Constants.NUM_GENERATIONS) {
            terminate = true;
            System.out.println("Terminating (generation = " + generationCount + ") because max generations reached");
        } else if (saturationCount >= Constants.SATURATION_POINT) {
            terminate = true;
            System.out.println("Terminating(generation = " + generationCount + ") because saturation point reached");
        } else if (Constants.IS_PURE_RANDOM_SEARCH) {
            terminate = true;
            System.out.println("Terminating(generation = " + generationCount + ") because pure random search");
        }

        return terminate;
    }

    public void printPopulation(List<GAChromosome> population) {
//        int count = 1;
//        System.out.println("(Size = " + population.size() + ")");
//        for (GAChromosome c : population) {
//            System.out.println(count + ". " + c);
//            count++;
//        }
        System.err.println("Activity: "+ SALEM.getCurrentActivityName());
        int count = 1;
        System.err.println("(Size = " + population.size() + ")");
        for (GAChromosome c : population) {
            System.err.println(count + ". " + c);
            count++;
        }
    }



    // This method is used for the new apporach with SegmentRelation
    public GAChromosome runGASegmentRelation() throws IOException, InterruptedException {

//        doCloudSetup();

        // initialize population with suggested values from Google
        System.out.println("\nRunning initialization");

        int populationSize = Constants.POPULATION_SIZE;
        if (Constants.IS_PURE_RANDOM_SEARCH) {
            populationSize = Constants.POPULATION_SIZE * Constants.NUM_GENERATIONS;
        }
        initialize(populationSize);

//        FitnessFunction ff = new FitnessFunction();
//Ali no need now
//        if(Constants.IS_PURE_RANDOM_SEARCH)
//        {
//            // for random search, break down the total population in groups of number of AWS instances
//            int cnt = 0;
//            List<GAChromosome> batch = new ArrayList<>();
//            List<GAChromosome> tempPopulation = new ArrayList<>();
//            int batchCnt = 0;
//            for(GAChromosome c : currentPopulation)
//            {
//                if(cnt < mFix.getAwsInstances().size())
//                {
//                    batch.add(c.copy());
//                    cnt++;
//                }
//                else
//                {
//                    tempPopulation.addAll(ff.calculateFitnessScoreForPopulation(batch, "initialization_batch" + batchCnt));
//                    cnt = 0;
//                    batch = new ArrayList<>();
//                    batchCnt++;
//                }
//            }
//            tempPopulation.addAll(ff.calculateFitnessScoreForPopulation(batch, "initialization_batch" + batchCnt));
//            currentPopulation = new ArrayList<>(tempPopulation);
//        }
//        else
//        {
//        FitnessFunction.setBaseSizeChange(null); // set the initial sizes to use as base for size change
//        currentPopulation = ff.calculateFitnessScoreForPopulation(currentPopulation, "initialization"); //Ali: Calling it directly created issue so i moved this method  to util class
        currentPopulation = Util.calculateFitnessScoreForPopulation(currentPopulation, "initialization");

//        }

        // sort current population by fitness score

        sortPopulationByFitnessScore(currentPopulation);
//        System.out.println("Sorted initial population = ");
//        printPopulation(currentPopulation);
//        System.out.println("Done initilization Exit ");
        System.err.println("Sorted initial population = ");
        printPopulation(currentPopulation);
        System.err.println("Done initialization Exit ");
//        System.exit(1);


        // start loop
        int saturationCount = 0;
        double prevGenFitnessScore = 0;

        while (!isTerminate(generationCount, saturationCount, currentPopulation.get(0).getFitnessFunctionObj().getA11yHeuristicsScore())) {
            System.out.println("\n----------------------------- GENERATION " + generationCount + " ------------------------------");
            nextGeneration = new ArrayList<>(currentPopulation);

            // uniform crossover
            System.out.println("\nRunning crossover");
            List<GAChromosome> nextGenerationCrossover = crossover();

            // uniform random mutation
            System.out.println("\nRunning mutation");
            List<GAChromosome> nextGenerationMutation = mutation();

            List<GAChromosome> crossoverMutationPopulation = new ArrayList<>();
            crossoverMutationPopulation.addAll(nextGenerationCrossover);
            crossoverMutationPopulation.addAll(nextGenerationMutation);
//            crossoverMutationPopulation = ff.calculateFitnessScoreForPopulation(crossoverMutationPopulation, "crossover_and_mutation");
            crossoverMutationPopulation = Util.calculateFitnessScoreForPopulation(crossoverMutationPopulation, "crossover_and_mutation");

            nextGeneration.addAll(crossoverMutationPopulation);
//            System.out.println("Population after crossover and mutation = ");
            System.err.println("Population after crossover and mutation = ");
            printPopulation(nextGeneration);

            // select
//            System.out.println("\nRunning selection");
//            select();
//            System.out.println("Population after selection = ");
//            printPopulation(currentPopulation);
            System.err.println("\nRunning selection");
            select();
            System.err.println("Population after selection = ");
            printPopulation(currentPopulation);

            if (prevGenFitnessScore == currentPopulation.get(0).getFitnessFunctionObj().getFitnessScore()) {
                saturationCount++;
            } else {
                saturationCount = 0;
            }
            prevGenFitnessScore = currentPopulation.get(0).getFitnessFunctionObj().getFitnessScore();
            generationCount++;
        }
        return currentPopulation.get(0); // optimal chromosome
    }




}
